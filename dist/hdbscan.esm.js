import{kdTree}from"kd-tree-javascript";class HierarchyNode{constructor(e,t,r,s){this.parent=e,this.child=t,this.lambda=r,this.size=s}}class DebugInfo{constructor(){}}class TreeNode{constructor(e){this.data=e}getAncestor(){return this.parent?this.parent.getAncestor():this}}class UnionFind{constructor(e){this.parent=new Array(2*(e-1)).fill(-1),this.nextLabel=e,this.size=new Array(e).fill(1).concat(new Array(e-1).fill(0))}union(e,t){this.size[this.nextLabel]=this.size[e]+this.size[t],this.parent[e]=this.nextLabel,this.parent[t]=this.nextLabel,this.size[this.nextLabel]=this.size[e]+this.size[t],this.nextLabel+=1}fastFind(e){for(var t=e;-1!=this.parent[e];)e=this.parent[e];for(;this.parent[t]!=e;)t=this.parent[t],this.parent[t]=e;return e}sizeOf(e){return this.size[e]}}class TreeUnionFind{constructor(e){this.data=new Array(e);for(var t=0;t<e;t++)this.data[t]=[t,0];this.isComponent=new Array(e).fill(!0)}union(e,t){e=this.find(e),t=this.find(t);this.data[e][1]<this.data[t][1]?this.data[e][0]=t:this.data[e][1]>this.data[t][1]?this.data[t][0]=e:(this.data[t][0]=e,this.data[e][1]+=1)}find(e){return this.data[e][0]!==e&&(this.data[e][0]=this.find(this.data[e][0]),this.isComponent[e]=!1),this.data[e][0]}components(){return[...Array(this.isComponent.length).keys()].filter(e=>this.isComponent[e])}}function bfsFromHierarchy(t,e){var r=t.length;const s=2*r-r+1;var n=[e];let i=[];for(;n.length;)i=i.concat(n),(n=n.filter(e=>e>=s).map(e=>e-s)).length&&(n=n.map(e=>[t[e].parent,t[e].child]).flat());return i}function condenseTree(e,t){var r=2*e.length,s=Math.floor(r/2)+1,n=s+1,i=new Array(1+r).fill(0);i[r]=s;var a=[],r=bfsFromHierarchy(e,r);const o=new Array(r.length).fill(!1);for(const f of r)if(!(o[f]||f<s)){var l=e[f-s],c=l.parent,h=l.child,d=0<l.lambda?1/l.lambda:1/0,u=s<=c?e[c-s].size:1,l=s<=h?e[h-s].size:1;if(t<=u&&t<=l)i[c]=n,n+=1,a.push(new HierarchyNode(i[f],i[c],d,u)),i[h]=n,n+=1,a.push(new HierarchyNode(i[f],i[h],d,l));else if(u<t&&l<t){for(const p of bfsFromHierarchy(e,c))p<s&&a.push(new HierarchyNode(i[f],p,d,1)),o[p]=!0;for(const m of bfsFromHierarchy(e,h))m<s&&a.push(new HierarchyNode(i[f],m,d,1)),o[m]=!0}else if(u<t){i[h]=i[f];for(const g of bfsFromHierarchy(e,c))g<s&&a.push(new HierarchyNode(i[f],g,d,1)),o[g]=!0}else{i[c]=i[f];for(const b of bfsFromHierarchy(e,h))b<s&&a.push(new HierarchyNode(i[f],b,d,1)),o[b]=!0}}return{bfsNodes:r,condensedTree:a}}function computeStabilities(e){var t=Math.max(...e.map(e=>e.child)),r=Math.min(...e.map(e=>e.parent)),s=Math.max(...e.map(e=>e.parent))-r+1;t<r&&(t=r);const n=e.map(e=>[e.child,e.lambda]).sort((e,t)=>e[0]-t[0]),i=new Array(t+1).fill(NaN);for(var a=n.map(e=>e[0]),o=n.map(e=>e[1]),l=e.map(e=>e.parent),c=e.map(e=>e.size),h=e.map(e=>e.lambda),d=-1,u=0,f=0;f<n.length;f++)var p=a[f],m=o[f],u=p==d?Math.min(u,m):(d=(-1!=d&&(i[d]=u),p),m);-1!=d&&(i[d]=u),i[r]=0;const g=new Array(s).fill(0);for(var b=0;b<e.length;b++){var w=l[b],v=h[b],y=c[b];g[w-r]+=(v-i[w])*y}for(var M=new Map,b=0;b<g.length;b++)M.set(r+b,g[b]);return M}function bfsFromClusterTree(e,t){var r=[t];let s=[];for(;r.length;)s=s.concat(r),r=e.filter(e=>-1!==r.indexOf(e.parent)).map(e=>e.child);return s}function getClusterNodes(e,t,r="eom",s=!1,n=0,i=0){if("eom"!==r)throw Error("Only eom method is supported now.");if(0!==n)throw Error("epsilon selection is not supported now.");if(s)throw Error("singleCluster is not supported now.");n=s?[...t.keys()].sort((e,t)=>t-e):[...t.keys()].sort((e,t)=>t-e).slice(0,t.size-1);const a=e.filter(e=>1<e.size),o=new Map;n.forEach(e=>o.set(e,!0));s=e.filter(e=>1===e.size).map(e=>e.child),s=Math.max(...s)+1;Math.max(...e.map(e=>e.lambda)),i<=0&&(i=s+1);const l=new Map;a.forEach(e=>l.set(e.child,e.size));for(const p of n){const m=a.filter(e=>e.parent===p).map(e=>e.child);var c=m.map(e=>t.get(e)||0).reduce((e,t)=>e+t,0);if(c>(t.get(p)||0)||(l.get(p)||0)>i)o.set(p,!1),t.set(p,c);else for(const g of bfsFromClusterTree(a,p))g!==p&&o.set(g,!1)}var h=[...o.entries()].filter(e=>e[1]).map(e=>e[0]).sort();const d=new Map,u=new Map;for(var f=0;f<h.length;f++)d.set(h[f],f),u.set(f,h[f]);return{clusterNodes:h,clusterNodesMap:d,revClusterNodesMap:u,clusterTree:a}}function labelClusters(e,t,r,s=!1,n=0,i=!1){if(0!==n)throw Error("epsilon selection is not supported now.");if(s)throw Error("singleCluster is not supported now.");if(i)throw Error("matchReferenceImplementation is not supported now.");var a=e.map(e=>e.parent),o=e.map(e=>e.child),l=Math.min(...a);const c=new Array(l);var h=Math.max(...a);const d=new TreeUnionFind(h+1);for(var u=0;u<e.length;u++){var f=o[u],p=a[u];-1===t.indexOf(f)&&d.union(p,f)}for(var m,g,u=0;u<l;u++){const b=d.find(u);b<l?c[u]=-1:b===l?1===t.length&&s?(g=e.find(e=>e.child===u),0!==n?g&&g.lambda>=1/n?c[u]=r.get(b):c[u]=-1:(m=e.filter(e=>e.child===b).map(e=>e.lambda),g&&m&&g.lambda>=Math.max(...m)?c[u]=r.get(b):c[u]=-1)):c[u]=-1:i?(m=(g=e.find(e=>e.child===u))&&g.lambda,g=(g=e.find(e=>e.child===b))&&g.lambda,c[u]=m&&g&&g<m?r.get(b):-1):c[u]=r.get(b)}return c}function getClustersAndNoise(e){const t=[],r=[];for(var s=0;s<e.length;s++){var n=e[s];-1===n?r.push(s):(t[n]||(t[n]=[]),t[n].push(s))}return{clusters:t,noise:r}}function kdTreeCoreDistance(e,t,r){const s=new kdTree(e,r,[]);return e.map(e=>s.nearest(e,t)[0][1])}function buildMstUsingPrim(e,t,r,s){var n=e.length;const i=[],a=[],o=new Array(n).fill(1/0);for(var l,c=0,h=1/0,d=1/0,u=1/0,f=1;f<n;f++){i[c]=1;for(var p,m=s[c],d=1/0,h=0,g=0;g<n;g++)i[g]||(l=o[g],u=r(e[c],e[g]),1!=t&&(u/=t),p=s[g],l<m||l<p||l<u?l<d&&(d=l,h=g):(m<p?u<p&&(u=p):u<m&&(u=m),u<l?(o[g]=u)<d&&(d=u,h=g):l<d&&(d=l,h=g)));a[f-1]=new HierarchyNode(c,h,d,0),c=h}return a}function sortMst(e){return e.sort((e,t)=>e.lambda-t.lambda)}function mstToBinaryTree(e){const n=[...new Array(e.length+1).keys()].map(e=>new TreeNode(e));var i=n[0];return sortMst(e).forEach(e=>{const t=n[e.parent].getAncestor(),r=n[e.child].getAncestor(),s=new TreeNode(e.lambda);s.left=t,s.right=r,t.parent=r.parent=i=s}),i}function createSingleLinkage(e){const t=new Array(e.length);for(var r=new UnionFind(e.length+1),s=0;s<e.length;++s){var n=e[s].parent,i=e[s].child,a=e[s].lambda,o=r.fastFind(n),n=r.fastFind(i),i=r.sizeOf(o)+r.sizeOf(n);t[s]=new HierarchyNode(o,n,a,i),r.union(o,n)}return t}function buildSingleLinkage(e,t=!1){var r=e;return{sortedMst:r=!t?sortMst(e):r,singleLinkage:createSingleLinkage(r)}}function kdTreePrim(e,t,r,s){var t=kdTreeCoreDistance(e,t,s),e=buildMstUsingPrim(e,r,s,t),{sortedMst:r,singleLinkage:s}=buildSingleLinkage(e);return{coreDistances:t,mst:e,sortedMst:r,singleLinkage:s}}function euclidean(e,t){for(var r=0,s=0;s<e.length;s++)r+=Math.pow(e[s]-t[s],2);return Math.sqrt(r)}class Hdbscan{constructor({input:e,minClusterSize:t=5,minSamples:r=5,alpha:s=1,metric:n=euclidean,debug:i=!1}){this.input=e,this.minClusterSize=t,this.minSamples=r,this.alpha=s,this.metric=n,this.debug=i;let a;try{var o,{coreDistances:l,mst:c,sortedMst:h,singleLinkage:d}=kdTreePrim(this.input,this.minSamples,this.alpha,this.metric);this.debug&&(o=mstToBinaryTree(h),a={coreDistances:l,mst:c,sortedMst:h,mstBinaryTree:o,singleLinkage:d});var{bfsNodes:u,condensedTree:f}=condenseTree(d,this.minClusterSize);this.debug&&(a=Object.assign(Object.assign({},a),{bfsNodes:u,condensedTree:f}));var p=computeStabilities(f);this.debug&&(a=Object.assign(Object.assign({},a),{condensedTree:f}));var{clusterNodes:m,clusterNodesMap:g,revClusterNodesMap:b,clusterTree:w}=getClusterNodes(f,p);this.debug&&(a=Object.assign(Object.assign({},a),{clusterNodes:m,clusterNodesMap:g,revClusterNodesMap:b,clusterTree:w}));var v=labelClusters(f,m,g);this.debug&&(a=Object.assign(Object.assign({},a),{labeledInputs:v}));var{clusters:y,noise:M}=getClustersAndNoise(v);this.debug&&(a=Object.assign(Object.assign({},a),{clusters:y,noise:M}),console.debug("debugInfo: ",a)),this.debugInfo=a,this.clusters=y,this.noise=M}catch(e){throw this.debug&&(console.debug("debugInfo: ",a),console.error("Error: Hdbscan: ",e)),e}}getDebugInfo(){return this.debugInfo}getClusters(){return this.clusters}getNoise(){return this.noise}}export{DebugInfo,Hdbscan,HierarchyNode,TreeNode,euclidean};
